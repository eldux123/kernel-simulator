#include <iostream>
#include <vector>
#include <queue>
#include <map>
#include <string>
#include <sstream>
#include <iomanip>
#include <algorithm>
#include <cmath>
#include <deque>
#include <climits>

#include "../modules/mem/BuddyAllocator.h"
#include "../modules/disk/DiskScheduler.h"
#include "../modules/io/IOManager.h"
#include "../cli/CLI.h"

#ifdef _WIN32
#include <windows.h>
#endif

// ... [Previous code remains unchanged until SchedulerSJF class]

class SchedulerSJF {
private:
    int globalTick = 0;
    int nextPid = 1;
    std::map<int, PCB> processes;
    std::vector<int> readyQueue;
    int runningPid = -1;
    MemoryManager &memManager;

public:
    SchedulerSJF(MemoryManager &mm) : memManager(mm) {}

    int createProcess(int burst, int pages = 4) {
        int pid = nextPid++;
        PCB pcb(pid, burst, globalTick, pages);
        pcb.state = ProcState::READY;
        processes[pid] = pcb;
        readyQueue.push_back(pid);
        return pid;
    }

    void tick() {
        globalTick++;
        if (runningPid == -1) scheduleNext();
        
        // Actualizar waiting time de procesos en espera
        for (auto &kv : processes) {
            if (kv.second.state == ProcState::READY)
                kv.second.waitingTime++;
        }

        if (runningPid != -1) {
            PCB &p = processes[runningPid];
            p.state = ProcState::RUNNING;
            
            // Acceso a memoria
            bool pf = memManager.access(p.id, p.nextPageToAccess);
            if (pf) p.pageFaults++;
            p.pageAccesses++;
            p.nextPageToAccess = (p.nextPageToAccess + 1) % p.numPages;
            
            p.burstRemaining--;
            
            if (p.burstRemaining <= 0) {
                p.state = ProcState::TERMINATED;
                p.finishTick = globalTick;
                p.turnaround = p.finishTick - p.arrivalTick;
                memManager.freeFramesOfPid(p.id);
                runningPid = -1;
            }
        }
    }

    void runTicks(int n) { 
        for (int i = 0; i < n; i++) tick(); 
    }

    void scheduleNext() {
        // eliminar terminados
        readyQueue.erase(
            std::remove_if(readyQueue.begin(), readyQueue.end(), 
                [&](int pid) { return processes[pid].state == ProcState::TERMINATED; }),
            readyQueue.end()
        );
        
        if (!readyQueue.empty()) {
            // Encontrar el proceso con menor burst remaining (SJF)
            auto shortestJob = std::min_element(readyQueue.begin(), readyQueue.end(),
                [&](int a, int b) { return processes[a].burstRemaining < processes[b].burstRemaining; });
                
            runningPid = *shortestJob;
            readyQueue.erase(shortestJob);
        }
    }

    void listProcesses() const {
        std::cout << "\n--- Procesos (SJF) ---\n";
        std::cout << "PID  Estado   Burst  Waiting  Pages  Faults\n";
        for (const auto &kv : processes) {
            const PCB &p = kv.second;
            std::string state;
            switch (p.state) {
                case ProcState::NEW: state = "NEW"; break;
                case ProcState::READY: state = "READY"; break;
                case ProcState::RUNNING: state = "RUN"; break;
                case ProcState::TERMINATED: state = "TERM"; break;
                default: state = "???"; break;
            }
            std::cout << std::setw(4) << p.id << " " 
                      << std::setw(7) << state << " "
                      << std::setw(6) << p.burstRemaining << " "
                      << std::setw(7) << p.waitingTime << " "
                      << std::setw(6) << p.numPages << " "
                      << std::setw(6) << p.pageFaults << "\n";
        }
    }

    void showStats() const {
        double avgWait = 0, avgTurn = 0;
        int finished = 0;
        
        for (const auto &kv : processes) {
            const PCB &p = kv.second;
            if (p.state == ProcState::TERMINATED) {
                finished++;
                avgWait += p.waitingTime;
                avgTurn += p.turnaround;
            }
        }
        
        if (finished > 0) {
            avgWait /= finished;
            avgTurn /= finished;
        }
        
        std::cout << "\n--- EstadÃ­sticas SJF ---\n";
        std::cout << "Procesos terminados: " << finished << "\n";
        std::cout << "Tiempo promedio de espera: " << avgWait << "\n";
        std::cout << "Tiempo promedio de retorno: " << avgTurn << "\n";
        std::cout << "Tick actual: " << globalTick << "\n";
    }
};

int main() {
#ifdef _WIN32
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);
#endif

    // Inicializar componentes
    MemoryManager memManager(DEFAULT_NUM_FRAMES);
    ProducerConsumer prodCons(DEFAULT_BUFFER_SIZE);
    SchedulerRR scheduler(memManager, prodCons);
    SchedulerSJF schedulerSJF(memManager);
    DiskScheduler diskScheduler;
    IOManager ioManager;
    CLI cli(scheduler, schedulerSJF, memManager, diskScheduler, ioManager, prodCons);

    // Ejecutar CLI
    cli.run();

    return 0;
}